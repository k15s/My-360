## 1 ##

* f(n) = g(n) + h(n)
* g(n) is the weighted distance to go from the root to n.
* h(n) is the heuristic function that estimates the cost of the
  cheapest path from n to the goal

Consider a version of A* that expands every state at most once. In the
following, assume that there is only one goal state and that the version of A*
that breaks ties in favor of states with smaller g-values expands non-goal
states (if available) that have the same f-value and g-value as the goal state
before the goal state.

Let c be the cost of a cost-minimal path from the start state to the goal state

a) Consider a version of A* that breaks ties in favor of states with smaller
   g-values. Argue that this version of A* expands all non-goal states whose
   f-values are equal to c.

* if A* breaks ties based on smaller g-values, the algorithm prefers expanding
  nodes that are closer to the root.
* recall that we assume this version of A* (that breaks ties in favor of states
  with smaller g-values) expands non-goal states that have the same f(n) and
  g(n) as the goal state before the goal state.

* the goal state has h(n) = 0 since already at the goal, so goal state's
  f(n) = g(n)
* the goal state is the goal, so g(n) = c since ideally the weighted distance
  to go from root to this goal state = c
* therefore, the goal state f(n) = g(n) = c

* consider all non-goal states whose f(n) = c
* if f = c
    * c = g(n) + h(n)
    * h(n) >= 0
    * g(n) = c - h(n)
* now consider...
    * if h(n) = 0
        * g(n) = c
        * f(n) = g(n) + 0 = c + 0 = c
        * this non-goal state's f(n) is identical to the goal state's f value,
          making the initial problem statement's assumuption relevant, so we
          explore this non-goal state before the goal state
    * if h(n) > 0
      * g(n) < c
      * f(n) = g(n) + h(n) = c
      * since g(n) < c, this non-goal state has a smaller g value than that of
        the goal state, so this non-goal state is explored before the goal
        state

* therefore, with the above cases in mind, all non-goal states with f(n) = c
  will be expanded before the goal state

b) Consider a version of A* that breaks ties in favor of states with larger
   g-values. Argue that this version of A* might only expand some of the
   non-goal states whose f-values are equal to c.

* If A* breaks ties based on larger g values, the algorithm prefers expanding
  nodes that are further away from the root

* the goal state has h(n) = 0 since already at the goal, so goal state's
  f(n) = g(n)
* the goal state is the goal, so g(n) = c since ideally the weighted distance
  to go from root to this goal state = c
* therefore, the goal state f(n) = g(n) = c

* consider all non-goal states whose f(n) = c
* if f = c
    * c = g(n) + h(n)
    * h(n) >= 0
    * g(n) = c - h(n)
* now consider...
  * if h(n) > 0
      * g(n) < c
      * f(n) = g(n) + h(n) = c
      * since g(n) < c, this non-goal state has a smaller g value than that of
        the goal state, so the goal state would be explored before this
        non-goal state

* therefore, with the above case in mind, we've identified the possibility of
  the goal state being explored before non-goal states whose f-values = c

c) Based on a) and b), argue why a version of A* that breaks ties in favor of
   states with larger g-values expands no more states than a version of A* that
   breaks ties in favor of states with smaller g-values. You will need to take
   into account that both versions of A* can also expand states whose f-values
   are not equal to c.

* for non-goal states with f-values = c
    * given a and b above, we established that the A* version that breaks ties
      on larger g-values might only expand some non-goal states, and the A*
      version that breaks ties on smaller g-values expands all non-goal states
    * so in terms of the number of non-goal states expanded
        * A* breaking on larger g-values <= A* breaking on smaller g-values

* for non-goal states with f-values != c
    * both A* versions break ties based on g-values
    * they expand the same number of states in this case - they just break the
      tie by choosing a non-goal state and keep working

* therefore, A* that breaks ties on larger g-values expands no more states than
  its opposing version
    * by choosing larger g-values, it might only expand some of the non-goal
      states where f(n) = c rather than all of them
* so A* breaking on larger g-values typically performs better with that
  property in mind

## 2 ##

* admissible
    * h(n) must be admissible
    * h(n) should never oversetimate the cost to reach the goal from state n

* consistent
    * for every node n and every successor n' of n generated by any action a,
      the estimated cost of reaching the goal from n <= step cost to n' +
      estimated cost of reaching goal from n'
        * h(n) <= (step cost) + h(n')

* Consider the following graph

A -e1-> B -e3-> C -e4-> D -e5-> E
 ------e2------>

* h(A): 4
* h(B): 3
* h(C): 1
* h(D): 1
* h(E): 0

* e1 (A,B) has cost 4
* e2 (A,C) has cost 5
* e3 (B,C) has cost 0
* e4 (C,D) has cost 2
* e5 (D,E) has cost 1

* We only have to consider the e1, e2, and e3 for this example
* admissible
    * all h(n) values are underestimates
    * e.g. h(A) = 4, and 4 < actual cost to go from A to E
* consistent
    * consider B: 3 not < 0 + 1
* So we have a heuristic that is admissible but not consistent
* Now we just perform A*, expanding nodes in order of increasing f-values

                                             A
                                         f = g + h
                                         4 = 0 + 4
                                          order: 1

                                 B                        C
                             f = g + h                 f = g + h
                             7 = 4 + 3                 6 = 5 + 1
                             order: 3                  order: 2
                                                       pruned

                                 C                        D
                             f = g + h                  f = g + h
                             5 = 4 + 1                  8 = 7 + 1
                             order: 4                   pruned
                        second time we find C,
                        more optimal path than
                        first time, prune inferior
                        first C path


                                 D
                              f = g + h
                              7 = 6 + 1
                              order: 5


                                 E
                              f = g + h
                              7  = 7 + 0
                              order: 6
                              Goal state

* Order of expansion: A (start), C, B, C, D, E (goal)
* A* does find the optimal path (after expanding C the first time)
    * A -> B -> C -> D -> E
* The first time we reach C, it's via e2 with cost 5
* The second time we reach C, it's via e1 and a3, and these two actions have a
  total cost of 4
* So A* did not find the cost-minimal path from A to C when it is
  about to expand C for the first time
